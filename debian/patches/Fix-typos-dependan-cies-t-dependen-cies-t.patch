From: =?utf-8?q?Ferenc_W=C3=A1gner?= <wferi@niif.hu>
Date: Mon, 14 Sep 2015 07:28:16 +0200
Subject: Fix typos: dependan{cies,t} -> dependen{cies,t}

---
 ChangeLog                    |   22 +++++++++++-----------
 doc/msg-schema.txt           |    2 +-
 include/crm/pengine/status.h |    6 +++---
 include/crm/stonith-ng.h     |    2 +-
 pengine/allocate.c           |    6 +++---
 tools/crm_resource.c         |   22 +++++++++++-----------
 6 files changed, 30 insertions(+), 30 deletions(-)

diff --git a/ChangeLog b/ChangeLog
index 376ff53..5471155 100644
--- a/ChangeLog
+++ b/ChangeLog
@@ -260,7 +260,7 @@
   + Bug cl#5219 - pengine: Allow unrelated resources with a common colocation target to remain promoted
   + Bug cl#5222 - cib: Repair rolling update capability
   + Bug cl#5222 - Enable legacy mode whenever a broadcast update is detected
-  + Bug rhbz#1036631 - Stop members of cloned groups when dependancies are stopped
+  + Bug rhbz#1036631 - Stop members of cloned groups when dependencies are stopped
   + Bug rhbz#1054307 - cname pattern match should be more restrictive in init script
   + Bug rhbz#1057697 - Use native DBus library for systemd/upstart support to avoid problematic use of threads
   + Bug rhbz#1097457 - Limit the scope of the previous fix and include a helpful comment
@@ -435,7 +435,7 @@
   + attrd: Give remote-nodes ability to set attributes with attrd
   + attrd: Prevent inflation of attribute dampen intervals
   + attrd: Support SI units for attribute dampening
-  + Bug cl#5171 - pengine: Don't prevent clones from running due to dependant resources
+  + Bug cl#5171 - pengine: Don't prevent clones from running due to dependent resources
   + Bug cl#5179 - Corosync: Attempt to retrieve a peer's node name if it is not already known
   + Bug cl#5181 - corosync: Ensure node IDs are written to the CIB as unsigned integers
   + Bug rhbz#902407 - crm_resource: Handle --ban for master/slave resources as advertised
@@ -830,7 +830,7 @@
   + pengine: Detect reloads of previously migrated resources
   + pengine: Ensure post-migration stop actions occur before node shutdown
   + pengine: Log as loudly as possible when we cannot shut down a cluster node
-  + pengine: Reload of a resource no longer causes a restart of dependant resources
+  + pengine: Reload of a resource no longer causes a restart of dependent resources
   + pengine: Support limiting the number of concurrent live migrations
   + pengine: Support referencing templates in constraints
   + pengine: Support of referencing resource templates in resource sets
@@ -891,7 +891,7 @@
   + pengine: Bug lf#2575 - Use uname for migration variables, id is a UUID on heartbeat
   + pengine: Bug lf#2581 - Avoid group restart when clone (re)starts on an unrelated node
   + pengine: Bug lf#2613, lf#2619 - Group migration after failures and non-default utilization policies
-  + pengine: Bug suse#707150 - Prevent services being active if dependancies on clones are not satisfied
+  + pengine: Bug suse#707150 - Prevent services being active if dependencies on clones are not satisfied
   + pengine: Correctly recognise which recurring operations are currently active
   + pengine: Demote from Master does not clear previous errors
   + pengine: Ensure restarts due to definition changes cause the start action to be re-issued not probes
@@ -1205,7 +1205,7 @@
 - Changes since 1.0.5-4
   + pengine: Bug 2213 - Ensure groups process location constraints so that clone-node-max works for cloned groups
   + pengine: Bug lf#2153 - non-clones should not restart when clones stop/start on other nodes
-  + pengine: Bug lf#2209 - Clone ordering should be able to prevent startup of dependant clones
+  + pengine: Bug lf#2209 - Clone ordering should be able to prevent startup of dependent clones
   + pengine: Bug lf#2216 - Correctly identify the state of anonymous clones when deciding when to probe
   + pengine: Bug lf#2225 - Operations that require fencing should wait for 'stonith_complete' not 'all_stopped'.
   + pengine: Bug lf#2225 - Prevent clone peers from stopping while another is instance is (potentially) being fenced
@@ -1332,7 +1332,7 @@
 - Use bzipped upstream tarball.
 
 * Wed Jul  29 2009 Andrew Beekhof <andrew@beekhof.net> - 1.0.5-0.6.c9120a53a6ae.hg
-- Add back missing build auto* dependancies
+- Add back missing build auto* dependencies
 - Minor cleanups to the install directive
 
 * Tue Jul  28 2009 Andrew Beekhof <andrew@beekhof.net> - 1.0.5-0.5.c9120a53a6ae.hg
@@ -1344,7 +1344,7 @@
 - Use the global directive instead of define for variables
 - Use the haclient/hacluster group/user instead of daemon
 - Use the _configure macro
-- Fix install dependancies
+- Fix install dependencies
 
 * Fri Jul  24 2009 Andrew Beekhof <andrew@beekhof.net> - 1.0.4-3
 - Initial Fedora checkin
@@ -2008,7 +2008,7 @@
   + Medium: pengine: Implement a global 'stop-all-resources' option
   + Medium: pengine: Implement cibpipe, a tool for performing/simulating config changes "offline"
   + Medium: pengine: We do not allow colocation with specific clone instances
-  + Medium: Tools: pingd - Implement a stack-independant version of pingd
+  + Medium: Tools: pingd - Implement a stack-independent version of pingd
   + Medium: xml: Ship an xslt for upgrading from 0.6 to 0.7
 
 * Thu Jun 19 2008 Andrew Beekhof <abeekhof@suse.de> - 0.6.5-1
@@ -2100,7 +2100,7 @@
   + Medium: pengine: Ensure implies_left ordering constraints are always effective
   + Medium: pengine: Indicate each resources 'promotion' score
   + Medium: pengine: Prevent a possible use-of-NULL
-  + Medium: pengine: Reprocess the current action if it changed (so that any prior dependancies are updated)
+  + Medium: pengine: Reprocess the current action if it changed (so that any prior dependencies are updated)
   + Medium: tengine: Bug LF-1859 - Wait for fail-count updates to complete before terminating the transition
   + Medium: tengine: Bug LF:1859 - Do not abort graphs due to our own failcount updates
   + Medium: tengine: Bug LF:1859 - Prevent the TE from interupting itself
@@ -2130,12 +2130,12 @@
   + Medium: crmd: Delay starting the IPC server until we are fully functional
   + Medium: CTS: Fix the startup patterns
   + Medium: pengine: Bug 1820 - Allow the first resource in a group to be migrated
-  + Medium: pengine: Bug 1820 - Check the colocation dependancies of resources to be migrated
+  + Medium: pengine: Bug 1820 - Check the colocation dependencies of resources to be migrated
 
 * Mon Jan 14 2008 Andrew Beekhof <abeekhof@suse.de> - 0.6.0-1
 - This is the first release of the Pacemaker Cluster Resource Manager formerly part of Heartbeat.
 - For those looking for the GUI, mgmtd, CIM or TSA components, they are now found in
-  the new pacemaker-pygui project.  Build dependancies prevent them from being
+  the new pacemaker-pygui project.  Build dependencies prevent them from being
   included in Heartbeat (since the built-in CRM is no longer supported) and,
   being non-core components, are not included with Pacemaker.
 - Update source tarball to revision: c94b92d550cf
diff --git a/doc/msg-schema.txt b/doc/msg-schema.txt
index 683e4b8..3033708 100644
--- a/doc/msg-schema.txt
+++ b/doc/msg-schema.txt
@@ -56,7 +56,7 @@ Message examples:
 
 3.1) an admin request to add/remove/modify a resource
 3.2) an admin request to force a failover of a resource or a
-recomputation of the resource dependancies.
+recomputation of the resource dependencies.
 
 Message Notes:
 ##################
diff --git a/include/crm/pengine/status.h b/include/crm/pengine/status.h
index 1c40636..b88d5ae 100644
--- a/include/crm/pengine/status.h
+++ b/include/crm/pengine/status.h
@@ -226,8 +226,8 @@ enum pe_action_flags {
     pe_action_clear = 0x00400,
     pe_action_dangle = 0x00800,
 
-    pe_action_requires_any = 0x01000, /* This action requires one or mre of its dependancies to be runnable
-                                       * We use this to clear the runnable flag before checking dependancies
+    pe_action_requires_any = 0x01000, /* This action requires one or mre of its dependencies to be runnable
+                                       * We use this to clear the runnable flag before checking dependencies
                                        */
     pe_action_reschedule = 0x02000,
 };
@@ -373,7 +373,7 @@ enum pe_ordering {
 
     pe_order_asymmetrical          = 0x100000,  /* Indicates asymmetrical one way ordering constraint. */
     pe_order_load                  = 0x200000,  /* Only relevant if... */
-    pe_order_one_or_more           = 0x400000,  /* 'then' is only runnable if one or more of it's dependancies are too */
+    pe_order_one_or_more           = 0x400000,  /* 'then' is only runnable if one or more of it's dependencies are too */
     pe_order_anti_colocation       = 0x800000,
 
     pe_order_preserve              = 0x1000000, /* Hack for breaking user ordering constraints with container resources */
diff --git a/include/crm/stonith-ng.h b/include/crm/stonith-ng.h
index 7f6938a..4a8f971 100644
--- a/include/crm/stonith-ng.h
+++ b/include/crm/stonith-ng.h
@@ -352,7 +352,7 @@ int stonith_api_kick(uint32_t nodeid, const char *uname, int timeout, bool off);
 time_t stonith_api_time(uint32_t nodeid, const char *uname, bool in_progress);
 
 /*
- * Helpers for using the above functions without install-time dependancies
+ * Helpers for using the above functions without install-time dependencies
  *
  * Usage:
  *  #include <crm/stonith-ng.h>
diff --git a/pengine/allocate.c b/pengine/allocate.c
index 2306747..1f65673 100644
--- a/pengine/allocate.c
+++ b/pengine/allocate.c
@@ -302,7 +302,7 @@ check_action_definition(resource_t * rsc, node_t * active_node, xmlNode * xml_op
             pe_rsc_trace(rsc, "Resource %s doesn't know how to reload", rsc->id);
 
             /* Re-send the start/demote/promote op
-             * Recurring ops will be detected independantly
+             * Recurring ops will be detected independently
              */
             custom_action(rsc, key, task, NULL, FALSE, TRUE, data_set);
         }
@@ -1338,7 +1338,7 @@ any_managed_resources(pe_working_set_t * data_set)
 }
 
 /*
- * Create dependancies for stonith and shutdown operations
+ * Create dependencies for stonith and shutdown operations
  */
 gboolean
 stage6(pe_working_set_t * data_set)
@@ -1466,7 +1466,7 @@ stage6(pe_working_set_t * data_set)
 }
 
 /*
- * Determin the sets of independant actions and the correct order for the
+ * Determin the sets of independent actions and the correct order for the
  *  actions in each set.
  *
  * Mark dependencies of un-runnable actions un-runnable
diff --git a/tools/crm_resource.c b/tools/crm_resource.c
index 52b25b1..5c225c8 100644
--- a/tools/crm_resource.c
+++ b/tools/crm_resource.c
@@ -632,7 +632,7 @@ set_resource_attr(const char *rsc_id, const char *attr_set, const char *attr_id,
             }
         }
 
-        crm_debug("Looking for dependancies %p", rsc->rsc_cons_lhs);
+        crm_debug("Looking for dependencies %p", rsc->rsc_cons_lhs);
         set_bit(rsc->flags, pe_rsc_allocating);
         for (lpc = rsc->rsc_cons_lhs; lpc != NULL; lpc = lpc->next) {
             rsc_colocation_t *cons = (rsc_colocation_t *) lpc->data;
@@ -641,7 +641,7 @@ set_resource_attr(const char *rsc_id, const char *attr_set, const char *attr_id,
             crm_debug("Checking %s %d", cons->id, cons->score);
             if (cons->score > 0 && is_not_set(peer->flags, pe_rsc_allocating)) {
                 /* Don't get into colocation loops */
-                crm_debug("Setting %s=%s for dependant resource %s", attr_name, attr_value, peer->id);
+                crm_debug("Setting %s=%s for dependent resource %s", attr_name, attr_value, peer->id);
                 set_resource_attr(peer->id, NULL, NULL, attr_name, attr_value, recursive, cib, data_set);
             }
         }
@@ -1218,7 +1218,7 @@ show_location(resource_t * rsc, const char *prefix)
 }
 
 static void
-show_colocation(resource_t * rsc, gboolean dependants, gboolean recursive, int offset)
+show_colocation(resource_t * rsc, gboolean dependents, gboolean recursive, int offset)
 {
     char *prefix = NULL;
     GListPtr lpc = NULL;
@@ -1227,7 +1227,7 @@ show_colocation(resource_t * rsc, gboolean dependants, gboolean recursive, int o
     prefix = calloc(1, (offset * 4) + 1);
     memset(prefix, ' ', offset * 4);
 
-    if (dependants) {
+    if (dependents) {
         list = rsc->rsc_cons_lhs;
     }
 
@@ -1245,26 +1245,26 @@ show_colocation(resource_t * rsc, gboolean dependants, gboolean recursive, int o
         char *score = NULL;
         resource_t *peer = cons->rsc_rh;
 
-        if (dependants) {
+        if (dependents) {
             peer = cons->rsc_lh;
         }
 
         if (is_set(peer->flags, pe_rsc_allocating)) {
-            if (dependants == FALSE) {
+            if (dependents == FALSE) {
                 fprintf(stdout, "%s%-*s (id=%s - loop)\n", prefix, 80 - (4 * offset), peer->id,
                         cons->id);
             }
             continue;
         }
 
-        if (dependants && recursive) {
-            show_colocation(peer, dependants, recursive, offset + 1);
+        if (dependents && recursive) {
+            show_colocation(peer, dependents, recursive, offset + 1);
         }
 
         score = score2char(cons->score);
         if (cons->role_rh > RSC_ROLE_STARTED) {
             fprintf(stdout, "%s%-*s (score=%s, %s role=%s, id=%s)\n", prefix, 80 - (4 * offset),
-                    peer->id, score, dependants ? "needs" : "with", role2text(cons->role_rh),
+                    peer->id, score, dependents ? "needs" : "with", role2text(cons->role_rh),
                     cons->id);
         } else {
             fprintf(stdout, "%s%-*s (score=%s, id=%s)\n", prefix, 80 - (4 * offset),
@@ -1273,8 +1273,8 @@ show_colocation(resource_t * rsc, gboolean dependants, gboolean recursive, int o
         show_location(peer, prefix);
         free(score);
 
-        if (!dependants && recursive) {
-            show_colocation(peer, dependants, recursive, offset + 1);
+        if (!dependents && recursive) {
+            show_colocation(peer, dependents, recursive, offset + 1);
         }
     }
     free(prefix);
